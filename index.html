<html>
<head>
  <!--
  <script type="text/javascript" src="bower_components/jquery/dist/jquery.min.js"></script>
  <script type="text/javascript" src="bower_components/threejs/build/three.min.js"></script>
  <script type="text/javascript" src="bower_components/threejs/examples/js/controls/TrackballControls.js"></script>
  -->
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script type="text/javascript" src="http://threejs.org/build/three.min.js"></script>
  <script type="text/javascript" src="http://threejs.org/examples/js/controls/TrackballControls.js"></script>
  <style>
  body {
    margin: 0px;
    background-color: #aaaaff;
    overflow: hidden;
  }
  </style>
  <script id="vertexShader" type="x-shader/x-vertex">
  uniform sampler2D bumpTexture;
  uniform float bumpScale;
  //varying float vAmount;
  varying vec2 vUV;

  void main()
  {
    vUV = uv;
    vec4 bumpData = texture2D( bumpTexture, uv );
    float vAmount = bumpData.r;
    vec3 newPosition = position + normal * bumpScale * vAmount;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
  }
  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">
  uniform sampler2D wrapTexture;
  //varying float vAmount;  // if we want to do height dependent shading.
  varying vec2 vUV;

  void main()
  {
    vec4 color = texture2D( wrapTexture, vUV );
    gl_FragColor = color;
  }
  </script>

  <script>
  var scene = new THREE.Scene();
  var width  = window.innerWidth,
  height = window.innerHeight;
  var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 0);
  camera.position.y = -500;
  camera.position.z = 500;
  var controls = new THREE.TrackballControls(camera);

  var ambientLight = new THREE.AmbientLight( 0xffffff );
  scene.add( ambientLight );
  var renderer = new THREE.WebGLRenderer();
  renderer.setSize(width, height);

  function render() {
    controls.update();
    requestAnimationFrame(render);
    renderer.render(scene, camera);
  }

  var htMapParams = {
    REQUEST:'GetMap',
    STYLES:'boxfill/greyscale',
    FORMAT:'image/png',
    HEIGHT:1024,
    WIDTH:1024,
    BBOX:'48.77,-10.12,59.29,2.43',
    CRS:'EPSG:4326',
    LAYER:'topo',
    VERSION:'1.3.0',
    LAYERS:'topo',
    COLORSCALERANGE:'0,1000',
    NUMCOLORBANDS:'253',
    ABOVEMAXCOLOR:'extend'
  };

  var htMapUrl = 'http://ec2-52-16-245-62.eu-west-1.compute.amazonaws.com:8080/' +
  'thredds/wms/testLab/global_dem_unmasked.nc?';

  var landTxtrParams = {
    request:'getmap',
    service:'wms',
    BBOX:'-10.12,48.77,2.43,59.29',
    srs:'EPSG:4326',
    format:'image/jpeg',
    layers:'gebco_latest',
    width:1024,
    height:1024,
    version:'1.1.1'
  };

  var landTxtrUrl = 'http://www.gebco.net/' +
  'data_and_products/gebco_web_services/web_map_service/mapserv?';

  var cloudBaseParams= {
    REQUEST:'GetCoverage',
    SERVICE:'WCS',
    VERSION:'1.0',
    COVERAGE:'UKPPBEST_Cloud_base',
    ELEVATION:'cloud-base',
    model:'UKPPBEST',
    CRS:'EPSG:4326',
    BBOX:'-10.12,48.77,2.43,59.29',
    WIDTH:256,
    HEIGHT:256,
  };

  var cloudBaseUrl = 'http://python-wetoffice.rhcloud.com/tiffpngf?';

  var cloudCoverParams= {
    REQUEST:'GetCoverage',
    SERVICE:'WCS',
    VERSION:'1.0',
    COVERAGE:'UKPPBEST_Total_cloud_cover',
    ELEVATION:'atmosphere',
    model:'UKPPBEST',
    CRS:'EPSG:4326',
    BBOX:'-10.12,48.77,2.43,59.29',
    WIDTH:256,
    HEIGHT:256,
  }

  var cloudCoverUrl = 'http://python-wetoffice.rhcloud.com/tiffpngf?';

  var bumpScale = 4.0;

  customUniforms = {
    bumpTexture:	{ type: "t", value: undefined },
    bumpScale:	    { type: "f", value: bumpScale },
    wrapTexture: { type: "t", value: undefined }
  };

  cloudUniforms = {
    bumpTexture:	{ type: "t", value: undefined },
    bumpScale:	    { type: "f", value: bumpScale },
    wrapTexture: { type: "t", value: undefined }
  };

  function loadWmsImage( url, params, cb ){
    var tmpImage = new Image();
    var wmsPng = url + jQuery.param( params );
    tmpImage.onload = function(){
      var canv = document.createElement('canvas');
      var ctx = canv.getContext('2d');
      canv.width = this.width;
      canv.height = this.height;
      ctx.drawImage(this, 0, 0);
      cb(canv.toDataURL());
    }
    tmpImage.crossOrigin = 'anonymous';
    tmpImage.src =  wmsPng;
  }

  // This function requires a simple WCS proxy.
  // The proxy fetches GeoTIFFfloat data, i.e.
  // grid of 32 bit floating point numbers which it packs
  // into a PNG image.
  function loadWcsData( url, params, obj, cb ){
    var tmpImage = new Image();
    var wcsPng = url + jQuery.param( params );
    tmpImage.onload = function(){
      var canv = document.createElement('canvas');
      var ctx = canv.getContext('2d');
      canv.width = this.width;
      canv.height = this.height;
      ctx.drawImage(this, 0, 0);
      var imageData = ctx.getImageData(0,0,this.width, this.height).data;
      var buffer = new ArrayBuffer(imageData.length);
      // Write to the buffer as bytes - always
      (new Uint8Array(buffer)).set( imageData );
      var floatArray = new Float32Array(buffer);
      cb(floatArray,canv.width,canv.height, obj);
    }
    tmpImage.crossOrigin = 'anonymous';
    tmpImage.src =  wcsPng;
  }

// Call like this:
// pfn = htMapPaletteFn({0: 'rgba(0,0,0,0.0)', 1:'rgba(255,255,255,1.0)'});
// rgba = pfn(i);
// Where i is in range 0.0 to 255.0
  htMapPaletteFn = function(colorStops) {
  var canvas = document.createElement( 'canvas' );
  canvas.width = 256;
  canvas.height = 1;

  var context = canvas.getContext( '2d' );
  var grad = context.createLinearGradient(0,0,256,0);
  for (var stop in colorStops){
    grad.addColorStop( stop, colorStops[stop] );
  }
  context.fillStyle = grad;
  context.fillRect(0, 0, 256, 1);

  var palette = [], r, g, b, a;
  var image = context.getImageData( 0, 0, canvas.width, 1 );
  for ( var i = 0; i < image.data.length; i += 4 ) {
    r = image.data[ i ];
    g = image.data[ i + 1 ];
    b = image.data[ i + 2 ];
    a = image.data[ i + 3 ];
    palette.push({r:r,g:g,b:b,a:a});
  }
  var fn = function(v){
    v = ~~v;  // removes fractional part of float
    v = (v>255) ? 255 : v;
    v = (v<0) ? 0 : v;
    return palette[v];
  };
  return fn;
}


  loadWmsImage( htMapUrl, htMapParams,
    function(img){
      customUniforms.bumpTexture.value = new THREE.ImageUtils.loadTexture(img);


    }
  );

  loadWmsImage( landTxtrUrl, landTxtrParams,
    function(img){
      customUniforms.wrapTexture.value = new THREE.ImageUtils.loadTexture(img);

    }
  );

  var coverobj = {};
  coverobj.canvas = document.createElement( 'canvas' );
  coverobj.texture = new THREE.Texture( coverobj.canvas );
  coverobj.material = new THREE.MeshPhongMaterial({side: THREE.DoubleSide,
      map: coverobj.texture, transparent: true,
      specular: 0xffffff,
      shininess: 20});
  coverobj.plane = new THREE.PlaneBufferGeometry( 512, 512, 511, 511 );
  coverobj.mesh = new THREE.Mesh(	coverobj.plane, coverobj.material );
  coverobj.mesh.position.z = 10;
  //scene.add( coverobj.mesh );

  loadWcsData( cloudCoverUrl, cloudCoverParams, coverobj,
    function(floatArray, width, height, obj){
      console.warn('have cloud data');
      var max = Math.max.apply( null, floatArray );
      console.log('max', max);
      var min = Math.min.apply( null, floatArray );
      console.log('min', min);
      pfn = htMapPaletteFn({0: 'rgba(255,255,255,0.0)', 1:'rgba(255,255,255,0.7)'});
      coverobj.canvas.width = width;
      coverobj.canvas.height = height;
      var ctx = coverobj.canvas.getContext( '2d' );
      var imageData = ctx.createImageData(width, height);
      for ( var i = 0, j = 0, l = imageData.data.length; i < l; i += 4, j++ ) {
        var rgba = pfn( floatArray[j] * 255/max );
        imageData.data[i] = rgba.r;
        imageData.data[i+1] = rgba.g;
        imageData.data[i+2] = rgba.b;
        imageData.data[i+3] = rgba.a;
      }
      ctx.putImageData( imageData, 0, 0 );
      coverobj.texture.needsUpdate = true;
    }
  );

  var baseobj = {};
  baseobj.canvas = document.createElement( 'canvas' );
  baseobj.texture = new THREE.Texture( baseobj.canvas );
  baseobj.material = new THREE.MeshPhongMaterial({side: THREE.DoubleSide,
      map: baseobj.texture});
  baseobj.plane = new THREE.PlaneBufferGeometry( 512, 512, 511, 511 );
  baseobj.mesh = new THREE.Mesh(	baseobj.plane, baseobj.material );
  baseobj.mesh.position.z = 30;
  //scene.add( baseobj.mesh );

  loadWcsData( cloudBaseUrl, cloudBaseParams, baseobj,
    function(floatArray, width, height, obj){
      console.warn('have cloud data');
      var max = Math.max.apply( null, floatArray );
      console.log('max', max);
      var min = Math.min.apply( null, floatArray );
      console.log('min', min);
      pfn = htMapPaletteFn({0: 'rgba(255,255,255,0.0)', 1:'rgba(255,255,255,0.8)'});
      obj.canvas.width = width;
      obj.canvas.height = height;
      var ctx = obj.canvas.getContext( '2d' );
      var imageData = ctx.createImageData(width, height);
      for ( var i = 0, j = 0, l = imageData.data.length; i < l; i += 4, j++ ) {
        var rgba = pfn( floatArray[j] * 255/max );
        imageData.data[i] = rgba.r;
        imageData.data[i+1] = rgba.g;
        imageData.data[i+2] = rgba.b;
        imageData.data[i+3] = rgba.a;
      }
      ctx.putImageData( imageData, 0, 0 );
      obj.texture.needsUpdate = true;
    }
  );
  // create custom material from the shader code above
  //   that is within specially labelled script tags

  cloudUniforms.wrapTexture.value = coverobj.texture;
  cloudUniforms.bumpTexture.value = baseobj.texture;

  var customMaterial = new THREE.ShaderMaterial(
    {
      uniforms: customUniforms,
      vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
      fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
      side: THREE.DoubleSide
    }   );

    var cloudMaterial = new THREE.ShaderMaterial(
      {
        uniforms: cloudUniforms,
        vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
        side: THREE.DoubleSide
      }   );

    {
      var plane = new THREE.PlaneBufferGeometry( 512, 512, 511, 511 );
      var mesh = new THREE.Mesh(	plane, customMaterial );
      scene.add( mesh );
    }
    /*
    {
      var material = new THREE.MeshPhongMaterial({ bumpMap: customUniforms.bumpTexture.value,
      bumpScale: 100.0,
		    map: customUniforms.wrapTexture.value, transparent: true, specular: 0x444444, shininess: 10 });
    var plane = new THREE.PlaneBufferGeometry( 512, 512, 511, 511 );
    var mesh = new THREE.Mesh(	plane, material );
    scene.add( mesh );
    }
    */
    /*
    {
      var plane = new THREE.PlaneBufferGeometry( 512, 512, 511, 511 );
      var mesh = new THREE.Mesh(	plane, cloudMaterial );
      scene.add( mesh );
    }
    */

    {
    //console.log('bump', baseobj.texture);
    console.log('bump', customUniforms.bumpTexture.value);
    console.log('map', coverobj.texture);
    var material = new THREE.MeshPhongMaterial({ bumpMap: customUniforms.bumpTexture.value,
      bumpScale: 1.0,
        map: coverobj.texture, transparent: true, specular: 0x444444, shininess: 10 });
    var plane = new THREE.PlaneBufferGeometry( 512, 512, 511, 511 );
    var mesh = new THREE.Mesh(	plane, material );
    scene.add( mesh );
    }



    </script>
  </head>
  <body>
    <div id="webgl"></div>
    <script>
    document.getElementById('webgl').appendChild(renderer.domElement);
    render();
    </script>
  </body>
  </html>
